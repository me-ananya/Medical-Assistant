# -*- coding: utf-8 -*-
"""Disease Recommendation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1n-0vUX0phg1PNqO7lJ6j4kN-oJaJWnn2
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
from scipy.stats import mode
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.svm import SVC
from sklearn.naive_bayes import GaussianNB
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, confusion_matrix

# %matplotlib inline

data = pd.read_csv('training_data.csv').dropna(axis = 1)
disease_counts = data["prognosis"].value_counts()
temp_df = pd.DataFrame({
	"Disease": disease_counts.index,
	"Counts": disease_counts.values
})

encoder = LabelEncoder()
data["prognosis"] = encoder.fit_transform(data["prognosis"])

X = data.iloc[:,:-1]
y = data.iloc[:, -1]
X_train, X_test, y_train, y_test =train_test_split(
X, y, test_size = 0.2, random_state = 24)

def cv_scoring(estimator, X, y):
	return accuracy_score(y, estimator.predict(X))

models = {
	"SVC":SVC(),
	"Gaussian NB":GaussianNB(),
	"Random Forest":RandomForestClassifier(random_state=18)
}

# Training and testing SVM Classifier
svm_model = SVC()
svm_model.fit(X_train, y_train)
preds = svm_model.predict(X_test)

# Training and testing Naive Bayes Classifier
nb_model = GaussianNB()
nb_model.fit(X_train, y_train)
preds = nb_model.predict(X_test)

# Training and testing Random Forest Classifier
rf_model = RandomForestClassifier(random_state=18)
rf_model.fit(X_train, y_train)
preds = rf_model.predict(X_test)

# Training the models on whole data
final_svm_model = SVC()
final_nb_model = GaussianNB()
final_rf_model = RandomForestClassifier(random_state=18)
final_svm_model.fit(X, y)
final_nb_model.fit(X, y)
final_rf_model.fit(X, y)

# Reading the test data
test_data = pd.read_csv("test_data.csv").dropna(axis=1)

test_X = test_data.iloc[:, :-1]
test_Y = encoder.transform(test_data.iloc[:, -1])

# Making prediction by take mode of predictions
# made by all the classifiers
svm_preds = final_svm_model.predict(test_X)
nb_preds = final_nb_model.predict(test_X)
rf_preds = final_rf_model.predict(test_X)

from collections import Counter

def custom_mode(lst):
    # Count occurrences of each element in the list
    counts = Counter(lst)
    # Find the element(s) with the maximum count
    max_count = max(counts.values())
    modes = [item for item, count in counts.items() if count == max_count]
    # If there is a tie for the mode, return the first one
    return modes[0]

final_preds = [custom_mode([i,j,k]) for i,j,k in zip(svm_preds, nb_preds, rf_preds)]

description_data = pd.read_csv("symptom_Description.csv")
precaution_data = pd.read_csv("symptom_precaution.csv")

from collections import Counter
symptoms = X.columns.values

symptom_index = {}
for index, value in enumerate(symptoms):
    symptom = " ".join([i.capitalize() for i in value.split("_")])
    symptom_index[symptom] = index

data_dict = {
    "symptom_index":symptom_index,
    "predictions_classes":encoder.classes_
}
def custom_mode(lst):
    counts = Counter(lst)
    max_count = max(counts.values())
    modes = [item for item, count in counts.items() if count == max_count]
    return modes[0]

def get_precautions(disease):
    precautions = precaution_data[precaution_data['Disease'] == disease].iloc[:, 1:].values.tolist()
    return precautions[0] if len(precautions) > 0 else ["No precautions available"]

def predictDisease(symptoms):
    symptoms = symptoms.split(",")

    input_data = [0] * len(data_dict["symptom_index"])
    for symptom in symptoms:
        index = data_dict["symptom_index"][symptom]
        input_data[index] = 1
    input_data = np.array(input_data).reshape(1,-1)

    rf_prediction = data_dict["predictions_classes"][final_rf_model.predict(input_data)[0]]
    nb_prediction = data_dict["predictions_classes"][final_nb_model.predict(input_data)[0]]
    svm_prediction = data_dict["predictions_classes"][final_svm_model.predict(input_data)[0]]

    # making final prediction by taking mode of all predictions
    final_prediction = custom_mode([rf_prediction, nb_prediction, svm_prediction])
    disp = description_data[description_data['Disease'] == final_prediction]['Description'].values[0] if final_prediction in description_data["Disease"].unique() else "No description available"
    predicted_disease = final_prediction
    precautions = get_precautions(predicted_disease)

    print ("Prediction:" + final_prediction)
    print ("Description:" + disp)
    print ("Precautions:")
    for pre in precautions:
      print("     "+ pre)
    return final_prediction

symptoms = [
    'itching', 'skin rash', 'nodal skin eruptions', 'continuous sneezing', 'shivering', 'chills', 'joint pain',
    'stomach pain', 'acidity', 'ulcers on tongue', 'muscle wasting', 'vomiting', 'burning micturition', 'fatigue',
    'weight gain', 'anxiety', 'cold hands and feets', 'mood swings', 'weight loss', 'restlessness', 'lethargy',
    'patches in throat', 'irregular sugar level', 'cough', 'high fever', 'sunken eyes', 'breathlessness', 'sweating',
    'dehydration', 'indigestion', 'headache', 'yellowish skin', 'dark urine', 'nausea', 'loss of appetite',
    'pain behind the eyes', 'back pain', 'constipation', 'abdominal pain', 'diarrhoea', 'mild fever', 'yellow urine',
    'yellowing of eyes', 'acute liver failure', 'fluid overload', 'swelling of stomach', 'swelled lymph nodes',
    'malaise', 'blurred and distorted vision', 'phlegm', 'throat irritation', 'redness of eyes', 'sinus pressure',
    'runny nose', 'congestion', 'chest pain', 'weakness in limbs', 'fast heart rate', 'pain during bowel movements',
    'pain in anal region', 'bloody stool', 'irritation in anus', 'neck pain', 'dizziness', 'cramps', 'bruising',
    'obesity', 'swollen legs', 'swollen blood vessels', 'puffy face and eyes', 'enlarged thyroid', 'brittle nails',
    'swollen extremeties', 'excessive hunger', 'extra marital contacts', 'drying and tingling lips', 'slurred speech',
    'knee pain', 'hip joint pain', 'muscle weakness', 'stiff neck', 'swelling joints', 'movement stiffness',
    'spinning movements', 'loss of balance', 'unsteadiness', 'weakness of one body side', 'loss of smell',
    'bladder discomfort', 'continuous feel of urine', 'passage of gases', 'internal itching', 'toxic look (typhos)',
    'depression', 'irritability', 'muscle pain', 'altered sensorium', 'red spots over body', 'belly pain',
    'abnormal menstruation', 'watering from eyes', 'increased appetite', 'polyuria', 'family history',
    'mucoid sputum', 'rusty sputum', 'lack of concentration', 'visual disturbances', 'receiving blood transfusion',
    'receiving unsterile injections', 'coma', 'stomach bleeding', 'distention of abdomen',
    'history of alcohol consumption', 'blood in sputum', 'prominent veins on calf', 'palpitations', 'painful walking',
    'pus filled pimples', 'blackheads', 'scurring', 'skin peeling', 'silver like dusting', 'small dents in nails',
    'inflammatory nails', 'blister', 'red sore around nose', 'yellow crust ooze'
]

# Function to print symptoms in an elegant format
def print_symptoms(symptoms):
    print("Symptoms:")
    for idx, symptom in enumerate(symptoms, start=1):
        print(f"{idx}. {symptom.capitalize()}")

print_symptoms(symptoms)

import warnings
warnings.filterwarnings("ignore", message="X does not have valid feature names", category=UserWarning)

user_input = input("Enter symptoms from the list above (comma separated, First letter of each word capital and no space between symptoms): ")
disease = predictDisease(user_input)

#disease = predictDisease("Blister,Skin Peeling")

# Function to load the doctor dataset
def load_doctor_data():
    return pd.read_csv("doctors.csv")  # Adjust file name and path as necessary

# Function to find doctors for a given disease
def find_doctors(predicted_disease, doctor_data):
    return doctor_data[doctor_data['Diseases'].str.contains(predicted_disease, case=False)]

# Ask user if they want to consult a doctor
consult_doctor = input("Do you want to consult a doctor? (Yes/No): ")

if consult_doctor.lower() == "yes":
    predicted_disease = disease

    # Load doctor dataset
    doctor_data = load_doctor_data()

    # Find doctors for the predicted disease
    matching_doctors = find_doctors(predicted_disease, doctor_data)

    if not matching_doctors.empty:
        print("Doctors available for the predicted disease:")
        for idx, doctor in matching_doctors.iterrows():
            print(f"Doctor Name: {doctor['DoctorName']}")
            print(f"Specialization: {doctor['Specialization']}")
            print(f"Age: {doctor['Age']}")
            print(f"Gender: {doctor['Gender']}")
            print(f"Address: {doctor['Address']}")
            print()
    else:
        print("No doctors available for the predicted disease.")
else:
    print("Okay, feel free to consult a doctor when needed.")